/* // dependencies:
//   flutter_secure_storage: ^10.0.0  # Latest as of Dec 2025 – check pub.dev
// For extra paranoia, add biometric checks via local_auth package.

  import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:http/http.dart' as http;  // For your API calls

class AuthService {
  // Singleton instance – secure storage is cheap to reuse
  static final _storage = const FlutterSecureStorage(
    // Android: Use hardware-backed Keystore (default in 2025)
    aOptions: AndroidOptions(
      encryptedSharedPreferences: true,
      keyCipherAlgorithm: KeyCipherAlgorithm.AES256_GCM,  // Stronger than defaults
    ),
    // iOS: Keychain with access control
    iOptions: IOSOptions(
      accessibility: KeychainItemAccessibility.first_unlock_this_device,
      accountName: 'your_app_token',  // Isolates your keys
    ),
  );

  // Save token after login – async, non-blocking
  static Future<void> saveToken(String token) async {
    await _storage.write(key: 'auth_token', value: token);
  }

  // Get token for requests – fresh every time, no stale BS
  static Future<String?> getToken() async {
    return await _storage.read(key: 'auth_token');
  }

  // Clear on logout – wipes it clean
  static Future<void> clearToken() async {
    await _storage.delete(key: 'auth_token');
  }

  // Example: Use in your API interceptor (e.g., with dio or http)
  static Future<http.Response> makeAuthenticatedRequest(String url) async {
    final token = await getToken();
    if (token == null) throw Exception('No token – log in first');

    return http.get(
      Uri.parse(url),
      headers: {'Authorization': 'Bearer $token'},  // Slap it on headers
    );
  }
} */